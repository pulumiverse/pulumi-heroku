// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package pipeline

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-heroku/sdk/go/heroku/internal"
)

// Provides a [Heroku Pipeline Coupling](https://devcenter.heroku.com/articles/pipelines)
// resource.
//
// A pipeline is a group of Heroku apps that share the same codebase. Once a
// pipeline is created using `pipeline.Pipeline`, and apps are added
// to different stages using `pipeline.Coupling`, you can promote app slugs
// to the downstream stages.
//
// See `pipeline.Pipeline` for complete usage documentation.
//
// ## Example Usage
//
// ## Import
//
// Pipeline couplings can be imported using the Pipeline coupling `id`, e.g.
//
// ```sh
// $ pulumi import heroku:pipeline/coupling:Coupling foobar 12345678
// ```
type Coupling struct {
	pulumi.CustomResourceState

	// Heroku app ID (do not use app name)
	AppId pulumi.StringOutput `pulumi:"appId"`
	// The ID of the pipeline to add this app to.
	Pipeline pulumi.StringOutput `pulumi:"pipeline"`
	// The stage to couple this app to. Must be one of
	// `review`, `development`, `staging`, or `production`.
	Stage pulumi.StringOutput `pulumi:"stage"`
}

// NewCoupling registers a new resource with the given unique name, arguments, and options.
func NewCoupling(ctx *pulumi.Context,
	name string, args *CouplingArgs, opts ...pulumi.ResourceOption) (*Coupling, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AppId == nil {
		return nil, errors.New("invalid value for required argument 'AppId'")
	}
	if args.Pipeline == nil {
		return nil, errors.New("invalid value for required argument 'Pipeline'")
	}
	if args.Stage == nil {
		return nil, errors.New("invalid value for required argument 'Stage'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Coupling
	err := ctx.RegisterResource("heroku:pipeline/coupling:Coupling", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCoupling gets an existing Coupling resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCoupling(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CouplingState, opts ...pulumi.ResourceOption) (*Coupling, error) {
	var resource Coupling
	err := ctx.ReadResource("heroku:pipeline/coupling:Coupling", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Coupling resources.
type couplingState struct {
	// Heroku app ID (do not use app name)
	AppId *string `pulumi:"appId"`
	// The ID of the pipeline to add this app to.
	Pipeline *string `pulumi:"pipeline"`
	// The stage to couple this app to. Must be one of
	// `review`, `development`, `staging`, or `production`.
	Stage *string `pulumi:"stage"`
}

type CouplingState struct {
	// Heroku app ID (do not use app name)
	AppId pulumi.StringPtrInput
	// The ID of the pipeline to add this app to.
	Pipeline pulumi.StringPtrInput
	// The stage to couple this app to. Must be one of
	// `review`, `development`, `staging`, or `production`.
	Stage pulumi.StringPtrInput
}

func (CouplingState) ElementType() reflect.Type {
	return reflect.TypeOf((*couplingState)(nil)).Elem()
}

type couplingArgs struct {
	// Heroku app ID (do not use app name)
	AppId string `pulumi:"appId"`
	// The ID of the pipeline to add this app to.
	Pipeline string `pulumi:"pipeline"`
	// The stage to couple this app to. Must be one of
	// `review`, `development`, `staging`, or `production`.
	Stage string `pulumi:"stage"`
}

// The set of arguments for constructing a Coupling resource.
type CouplingArgs struct {
	// Heroku app ID (do not use app name)
	AppId pulumi.StringInput
	// The ID of the pipeline to add this app to.
	Pipeline pulumi.StringInput
	// The stage to couple this app to. Must be one of
	// `review`, `development`, `staging`, or `production`.
	Stage pulumi.StringInput
}

func (CouplingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*couplingArgs)(nil)).Elem()
}

type CouplingInput interface {
	pulumi.Input

	ToCouplingOutput() CouplingOutput
	ToCouplingOutputWithContext(ctx context.Context) CouplingOutput
}

func (*Coupling) ElementType() reflect.Type {
	return reflect.TypeOf((**Coupling)(nil)).Elem()
}

func (i *Coupling) ToCouplingOutput() CouplingOutput {
	return i.ToCouplingOutputWithContext(context.Background())
}

func (i *Coupling) ToCouplingOutputWithContext(ctx context.Context) CouplingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CouplingOutput)
}

// CouplingArrayInput is an input type that accepts CouplingArray and CouplingArrayOutput values.
// You can construct a concrete instance of `CouplingArrayInput` via:
//
//	CouplingArray{ CouplingArgs{...} }
type CouplingArrayInput interface {
	pulumi.Input

	ToCouplingArrayOutput() CouplingArrayOutput
	ToCouplingArrayOutputWithContext(context.Context) CouplingArrayOutput
}

type CouplingArray []CouplingInput

func (CouplingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Coupling)(nil)).Elem()
}

func (i CouplingArray) ToCouplingArrayOutput() CouplingArrayOutput {
	return i.ToCouplingArrayOutputWithContext(context.Background())
}

func (i CouplingArray) ToCouplingArrayOutputWithContext(ctx context.Context) CouplingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CouplingArrayOutput)
}

// CouplingMapInput is an input type that accepts CouplingMap and CouplingMapOutput values.
// You can construct a concrete instance of `CouplingMapInput` via:
//
//	CouplingMap{ "key": CouplingArgs{...} }
type CouplingMapInput interface {
	pulumi.Input

	ToCouplingMapOutput() CouplingMapOutput
	ToCouplingMapOutputWithContext(context.Context) CouplingMapOutput
}

type CouplingMap map[string]CouplingInput

func (CouplingMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Coupling)(nil)).Elem()
}

func (i CouplingMap) ToCouplingMapOutput() CouplingMapOutput {
	return i.ToCouplingMapOutputWithContext(context.Background())
}

func (i CouplingMap) ToCouplingMapOutputWithContext(ctx context.Context) CouplingMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CouplingMapOutput)
}

type CouplingOutput struct{ *pulumi.OutputState }

func (CouplingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Coupling)(nil)).Elem()
}

func (o CouplingOutput) ToCouplingOutput() CouplingOutput {
	return o
}

func (o CouplingOutput) ToCouplingOutputWithContext(ctx context.Context) CouplingOutput {
	return o
}

// Heroku app ID (do not use app name)
func (o CouplingOutput) AppId() pulumi.StringOutput {
	return o.ApplyT(func(v *Coupling) pulumi.StringOutput { return v.AppId }).(pulumi.StringOutput)
}

// The ID of the pipeline to add this app to.
func (o CouplingOutput) Pipeline() pulumi.StringOutput {
	return o.ApplyT(func(v *Coupling) pulumi.StringOutput { return v.Pipeline }).(pulumi.StringOutput)
}

// The stage to couple this app to. Must be one of
// `review`, `development`, `staging`, or `production`.
func (o CouplingOutput) Stage() pulumi.StringOutput {
	return o.ApplyT(func(v *Coupling) pulumi.StringOutput { return v.Stage }).(pulumi.StringOutput)
}

type CouplingArrayOutput struct{ *pulumi.OutputState }

func (CouplingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Coupling)(nil)).Elem()
}

func (o CouplingArrayOutput) ToCouplingArrayOutput() CouplingArrayOutput {
	return o
}

func (o CouplingArrayOutput) ToCouplingArrayOutputWithContext(ctx context.Context) CouplingArrayOutput {
	return o
}

func (o CouplingArrayOutput) Index(i pulumi.IntInput) CouplingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Coupling {
		return vs[0].([]*Coupling)[vs[1].(int)]
	}).(CouplingOutput)
}

type CouplingMapOutput struct{ *pulumi.OutputState }

func (CouplingMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Coupling)(nil)).Elem()
}

func (o CouplingMapOutput) ToCouplingMapOutput() CouplingMapOutput {
	return o
}

func (o CouplingMapOutput) ToCouplingMapOutputWithContext(ctx context.Context) CouplingMapOutput {
	return o
}

func (o CouplingMapOutput) MapIndex(k pulumi.StringInput) CouplingOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Coupling {
		return vs[0].(map[string]*Coupling)[vs[1].(string)]
	}).(CouplingOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CouplingInput)(nil)).Elem(), &Coupling{})
	pulumi.RegisterInputType(reflect.TypeOf((*CouplingArrayInput)(nil)).Elem(), CouplingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CouplingMapInput)(nil)).Elem(), CouplingMap{})
	pulumi.RegisterOutputType(CouplingOutput{})
	pulumi.RegisterOutputType(CouplingArrayOutput{})
	pulumi.RegisterOutputType(CouplingMapOutput{})
}
