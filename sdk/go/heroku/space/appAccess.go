// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package space

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-heroku/sdk/go/heroku/internal"
)

// Provides a resource for managing permissions for the entire Private Space. Members with the admin role will
// always have full permissions in the Private Space, so using this resource on an admin will have no effect.
// The provided email must already be a member of the Heroku Team. Currently, the only supported permission is `createApps`.
//
// ## Example Usage
//
// ## Importing
//
// Existing permissions can be imported using the combination of the Private Space name, a colon, and the member email.
//
// For example:
type AppAccess struct {
	pulumi.CustomResourceState

	// The email of the existing Heroku Team member.
	Email pulumi.StringOutput `pulumi:"email"`
	// The permissions to grant the team member for the Private Space.
	// Currently `createApps` is the only supported permission. If not provided the member will have no permissions to the space.
	// Members with admin role will always have `createApps` permissions, which cannot be removed.
	Permissions pulumi.StringArrayOutput `pulumi:"permissions"`
	// The ID of the Private Space.
	Space pulumi.StringOutput `pulumi:"space"`
}

// NewAppAccess registers a new resource with the given unique name, arguments, and options.
func NewAppAccess(ctx *pulumi.Context,
	name string, args *AppAccessArgs, opts ...pulumi.ResourceOption) (*AppAccess, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Email == nil {
		return nil, errors.New("invalid value for required argument 'Email'")
	}
	if args.Permissions == nil {
		return nil, errors.New("invalid value for required argument 'Permissions'")
	}
	if args.Space == nil {
		return nil, errors.New("invalid value for required argument 'Space'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AppAccess
	err := ctx.RegisterResource("heroku:space/appAccess:AppAccess", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAppAccess gets an existing AppAccess resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAppAccess(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AppAccessState, opts ...pulumi.ResourceOption) (*AppAccess, error) {
	var resource AppAccess
	err := ctx.ReadResource("heroku:space/appAccess:AppAccess", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AppAccess resources.
type appAccessState struct {
	// The email of the existing Heroku Team member.
	Email *string `pulumi:"email"`
	// The permissions to grant the team member for the Private Space.
	// Currently `createApps` is the only supported permission. If not provided the member will have no permissions to the space.
	// Members with admin role will always have `createApps` permissions, which cannot be removed.
	Permissions []string `pulumi:"permissions"`
	// The ID of the Private Space.
	Space *string `pulumi:"space"`
}

type AppAccessState struct {
	// The email of the existing Heroku Team member.
	Email pulumi.StringPtrInput
	// The permissions to grant the team member for the Private Space.
	// Currently `createApps` is the only supported permission. If not provided the member will have no permissions to the space.
	// Members with admin role will always have `createApps` permissions, which cannot be removed.
	Permissions pulumi.StringArrayInput
	// The ID of the Private Space.
	Space pulumi.StringPtrInput
}

func (AppAccessState) ElementType() reflect.Type {
	return reflect.TypeOf((*appAccessState)(nil)).Elem()
}

type appAccessArgs struct {
	// The email of the existing Heroku Team member.
	Email string `pulumi:"email"`
	// The permissions to grant the team member for the Private Space.
	// Currently `createApps` is the only supported permission. If not provided the member will have no permissions to the space.
	// Members with admin role will always have `createApps` permissions, which cannot be removed.
	Permissions []string `pulumi:"permissions"`
	// The ID of the Private Space.
	Space string `pulumi:"space"`
}

// The set of arguments for constructing a AppAccess resource.
type AppAccessArgs struct {
	// The email of the existing Heroku Team member.
	Email pulumi.StringInput
	// The permissions to grant the team member for the Private Space.
	// Currently `createApps` is the only supported permission. If not provided the member will have no permissions to the space.
	// Members with admin role will always have `createApps` permissions, which cannot be removed.
	Permissions pulumi.StringArrayInput
	// The ID of the Private Space.
	Space pulumi.StringInput
}

func (AppAccessArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*appAccessArgs)(nil)).Elem()
}

type AppAccessInput interface {
	pulumi.Input

	ToAppAccessOutput() AppAccessOutput
	ToAppAccessOutputWithContext(ctx context.Context) AppAccessOutput
}

func (*AppAccess) ElementType() reflect.Type {
	return reflect.TypeOf((**AppAccess)(nil)).Elem()
}

func (i *AppAccess) ToAppAccessOutput() AppAccessOutput {
	return i.ToAppAccessOutputWithContext(context.Background())
}

func (i *AppAccess) ToAppAccessOutputWithContext(ctx context.Context) AppAccessOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppAccessOutput)
}

// AppAccessArrayInput is an input type that accepts AppAccessArray and AppAccessArrayOutput values.
// You can construct a concrete instance of `AppAccessArrayInput` via:
//
//	AppAccessArray{ AppAccessArgs{...} }
type AppAccessArrayInput interface {
	pulumi.Input

	ToAppAccessArrayOutput() AppAccessArrayOutput
	ToAppAccessArrayOutputWithContext(context.Context) AppAccessArrayOutput
}

type AppAccessArray []AppAccessInput

func (AppAccessArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AppAccess)(nil)).Elem()
}

func (i AppAccessArray) ToAppAccessArrayOutput() AppAccessArrayOutput {
	return i.ToAppAccessArrayOutputWithContext(context.Background())
}

func (i AppAccessArray) ToAppAccessArrayOutputWithContext(ctx context.Context) AppAccessArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppAccessArrayOutput)
}

// AppAccessMapInput is an input type that accepts AppAccessMap and AppAccessMapOutput values.
// You can construct a concrete instance of `AppAccessMapInput` via:
//
//	AppAccessMap{ "key": AppAccessArgs{...} }
type AppAccessMapInput interface {
	pulumi.Input

	ToAppAccessMapOutput() AppAccessMapOutput
	ToAppAccessMapOutputWithContext(context.Context) AppAccessMapOutput
}

type AppAccessMap map[string]AppAccessInput

func (AppAccessMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AppAccess)(nil)).Elem()
}

func (i AppAccessMap) ToAppAccessMapOutput() AppAccessMapOutput {
	return i.ToAppAccessMapOutputWithContext(context.Background())
}

func (i AppAccessMap) ToAppAccessMapOutputWithContext(ctx context.Context) AppAccessMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AppAccessMapOutput)
}

type AppAccessOutput struct{ *pulumi.OutputState }

func (AppAccessOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AppAccess)(nil)).Elem()
}

func (o AppAccessOutput) ToAppAccessOutput() AppAccessOutput {
	return o
}

func (o AppAccessOutput) ToAppAccessOutputWithContext(ctx context.Context) AppAccessOutput {
	return o
}

// The email of the existing Heroku Team member.
func (o AppAccessOutput) Email() pulumi.StringOutput {
	return o.ApplyT(func(v *AppAccess) pulumi.StringOutput { return v.Email }).(pulumi.StringOutput)
}

// The permissions to grant the team member for the Private Space.
// Currently `createApps` is the only supported permission. If not provided the member will have no permissions to the space.
// Members with admin role will always have `createApps` permissions, which cannot be removed.
func (o AppAccessOutput) Permissions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AppAccess) pulumi.StringArrayOutput { return v.Permissions }).(pulumi.StringArrayOutput)
}

// The ID of the Private Space.
func (o AppAccessOutput) Space() pulumi.StringOutput {
	return o.ApplyT(func(v *AppAccess) pulumi.StringOutput { return v.Space }).(pulumi.StringOutput)
}

type AppAccessArrayOutput struct{ *pulumi.OutputState }

func (AppAccessArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AppAccess)(nil)).Elem()
}

func (o AppAccessArrayOutput) ToAppAccessArrayOutput() AppAccessArrayOutput {
	return o
}

func (o AppAccessArrayOutput) ToAppAccessArrayOutputWithContext(ctx context.Context) AppAccessArrayOutput {
	return o
}

func (o AppAccessArrayOutput) Index(i pulumi.IntInput) AppAccessOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AppAccess {
		return vs[0].([]*AppAccess)[vs[1].(int)]
	}).(AppAccessOutput)
}

type AppAccessMapOutput struct{ *pulumi.OutputState }

func (AppAccessMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AppAccess)(nil)).Elem()
}

func (o AppAccessMapOutput) ToAppAccessMapOutput() AppAccessMapOutput {
	return o
}

func (o AppAccessMapOutput) ToAppAccessMapOutputWithContext(ctx context.Context) AppAccessMapOutput {
	return o
}

func (o AppAccessMapOutput) MapIndex(k pulumi.StringInput) AppAccessOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AppAccess {
		return vs[0].(map[string]*AppAccess)[vs[1].(string)]
	}).(AppAccessOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AppAccessInput)(nil)).Elem(), &AppAccess{})
	pulumi.RegisterInputType(reflect.TypeOf((*AppAccessArrayInput)(nil)).Elem(), AppAccessArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AppAccessMapInput)(nil)).Elem(), AppAccessMap{})
	pulumi.RegisterOutputType(AppAccessOutput{})
	pulumi.RegisterOutputType(AppAccessArrayOutput{})
	pulumi.RegisterOutputType(AppAccessMapOutput{})
}
