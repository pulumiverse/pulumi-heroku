// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package slug

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-heroku/sdk/go/heroku/internal"
)

type Slug struct {
	pulumi.CustomResourceState

	AppId                        pulumi.StringOutput    `pulumi:"appId"`
	Blobs                        SlugBlobArrayOutput    `pulumi:"blobs"`
	BuildpackProvidedDescription pulumi.StringPtrOutput `pulumi:"buildpackProvidedDescription"`
	Checksum                     pulumi.StringOutput    `pulumi:"checksum"`
	Commit                       pulumi.StringPtrOutput `pulumi:"commit"`
	CommitDescription            pulumi.StringPtrOutput `pulumi:"commitDescription"`
	FilePath                     pulumi.StringPtrOutput `pulumi:"filePath"`
	FileUrl                      pulumi.StringPtrOutput `pulumi:"fileUrl"`
	ProcessTypes                 pulumi.MapOutput       `pulumi:"processTypes"`
	Size                         pulumi.IntOutput       `pulumi:"size"`
	Stack                        pulumi.StringOutput    `pulumi:"stack"`
	StackId                      pulumi.StringOutput    `pulumi:"stackId"`
}

// NewSlug registers a new resource with the given unique name, arguments, and options.
func NewSlug(ctx *pulumi.Context,
	name string, args *SlugArgs, opts ...pulumi.ResourceOption) (*Slug, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AppId == nil {
		return nil, errors.New("invalid value for required argument 'AppId'")
	}
	if args.ProcessTypes == nil {
		return nil, errors.New("invalid value for required argument 'ProcessTypes'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Slug
	err := ctx.RegisterResource("heroku:slug/slug:Slug", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSlug gets an existing Slug resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSlug(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SlugState, opts ...pulumi.ResourceOption) (*Slug, error) {
	var resource Slug
	err := ctx.ReadResource("heroku:slug/slug:Slug", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Slug resources.
type slugState struct {
	AppId                        *string                `pulumi:"appId"`
	Blobs                        []SlugBlob             `pulumi:"blobs"`
	BuildpackProvidedDescription *string                `pulumi:"buildpackProvidedDescription"`
	Checksum                     *string                `pulumi:"checksum"`
	Commit                       *string                `pulumi:"commit"`
	CommitDescription            *string                `pulumi:"commitDescription"`
	FilePath                     *string                `pulumi:"filePath"`
	FileUrl                      *string                `pulumi:"fileUrl"`
	ProcessTypes                 map[string]interface{} `pulumi:"processTypes"`
	Size                         *int                   `pulumi:"size"`
	Stack                        *string                `pulumi:"stack"`
	StackId                      *string                `pulumi:"stackId"`
}

type SlugState struct {
	AppId                        pulumi.StringPtrInput
	Blobs                        SlugBlobArrayInput
	BuildpackProvidedDescription pulumi.StringPtrInput
	Checksum                     pulumi.StringPtrInput
	Commit                       pulumi.StringPtrInput
	CommitDescription            pulumi.StringPtrInput
	FilePath                     pulumi.StringPtrInput
	FileUrl                      pulumi.StringPtrInput
	ProcessTypes                 pulumi.MapInput
	Size                         pulumi.IntPtrInput
	Stack                        pulumi.StringPtrInput
	StackId                      pulumi.StringPtrInput
}

func (SlugState) ElementType() reflect.Type {
	return reflect.TypeOf((*slugState)(nil)).Elem()
}

type slugArgs struct {
	AppId                        string                 `pulumi:"appId"`
	BuildpackProvidedDescription *string                `pulumi:"buildpackProvidedDescription"`
	Checksum                     *string                `pulumi:"checksum"`
	Commit                       *string                `pulumi:"commit"`
	CommitDescription            *string                `pulumi:"commitDescription"`
	FilePath                     *string                `pulumi:"filePath"`
	FileUrl                      *string                `pulumi:"fileUrl"`
	ProcessTypes                 map[string]interface{} `pulumi:"processTypes"`
	Stack                        *string                `pulumi:"stack"`
}

// The set of arguments for constructing a Slug resource.
type SlugArgs struct {
	AppId                        pulumi.StringInput
	BuildpackProvidedDescription pulumi.StringPtrInput
	Checksum                     pulumi.StringPtrInput
	Commit                       pulumi.StringPtrInput
	CommitDescription            pulumi.StringPtrInput
	FilePath                     pulumi.StringPtrInput
	FileUrl                      pulumi.StringPtrInput
	ProcessTypes                 pulumi.MapInput
	Stack                        pulumi.StringPtrInput
}

func (SlugArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*slugArgs)(nil)).Elem()
}

type SlugInput interface {
	pulumi.Input

	ToSlugOutput() SlugOutput
	ToSlugOutputWithContext(ctx context.Context) SlugOutput
}

func (*Slug) ElementType() reflect.Type {
	return reflect.TypeOf((**Slug)(nil)).Elem()
}

func (i *Slug) ToSlugOutput() SlugOutput {
	return i.ToSlugOutputWithContext(context.Background())
}

func (i *Slug) ToSlugOutputWithContext(ctx context.Context) SlugOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SlugOutput)
}

// SlugArrayInput is an input type that accepts SlugArray and SlugArrayOutput values.
// You can construct a concrete instance of `SlugArrayInput` via:
//
//	SlugArray{ SlugArgs{...} }
type SlugArrayInput interface {
	pulumi.Input

	ToSlugArrayOutput() SlugArrayOutput
	ToSlugArrayOutputWithContext(context.Context) SlugArrayOutput
}

type SlugArray []SlugInput

func (SlugArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Slug)(nil)).Elem()
}

func (i SlugArray) ToSlugArrayOutput() SlugArrayOutput {
	return i.ToSlugArrayOutputWithContext(context.Background())
}

func (i SlugArray) ToSlugArrayOutputWithContext(ctx context.Context) SlugArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SlugArrayOutput)
}

// SlugMapInput is an input type that accepts SlugMap and SlugMapOutput values.
// You can construct a concrete instance of `SlugMapInput` via:
//
//	SlugMap{ "key": SlugArgs{...} }
type SlugMapInput interface {
	pulumi.Input

	ToSlugMapOutput() SlugMapOutput
	ToSlugMapOutputWithContext(context.Context) SlugMapOutput
}

type SlugMap map[string]SlugInput

func (SlugMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Slug)(nil)).Elem()
}

func (i SlugMap) ToSlugMapOutput() SlugMapOutput {
	return i.ToSlugMapOutputWithContext(context.Background())
}

func (i SlugMap) ToSlugMapOutputWithContext(ctx context.Context) SlugMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SlugMapOutput)
}

type SlugOutput struct{ *pulumi.OutputState }

func (SlugOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Slug)(nil)).Elem()
}

func (o SlugOutput) ToSlugOutput() SlugOutput {
	return o
}

func (o SlugOutput) ToSlugOutputWithContext(ctx context.Context) SlugOutput {
	return o
}

func (o SlugOutput) AppId() pulumi.StringOutput {
	return o.ApplyT(func(v *Slug) pulumi.StringOutput { return v.AppId }).(pulumi.StringOutput)
}

func (o SlugOutput) Blobs() SlugBlobArrayOutput {
	return o.ApplyT(func(v *Slug) SlugBlobArrayOutput { return v.Blobs }).(SlugBlobArrayOutput)
}

func (o SlugOutput) BuildpackProvidedDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Slug) pulumi.StringPtrOutput { return v.BuildpackProvidedDescription }).(pulumi.StringPtrOutput)
}

func (o SlugOutput) Checksum() pulumi.StringOutput {
	return o.ApplyT(func(v *Slug) pulumi.StringOutput { return v.Checksum }).(pulumi.StringOutput)
}

func (o SlugOutput) Commit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Slug) pulumi.StringPtrOutput { return v.Commit }).(pulumi.StringPtrOutput)
}

func (o SlugOutput) CommitDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Slug) pulumi.StringPtrOutput { return v.CommitDescription }).(pulumi.StringPtrOutput)
}

func (o SlugOutput) FilePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Slug) pulumi.StringPtrOutput { return v.FilePath }).(pulumi.StringPtrOutput)
}

func (o SlugOutput) FileUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Slug) pulumi.StringPtrOutput { return v.FileUrl }).(pulumi.StringPtrOutput)
}

func (o SlugOutput) ProcessTypes() pulumi.MapOutput {
	return o.ApplyT(func(v *Slug) pulumi.MapOutput { return v.ProcessTypes }).(pulumi.MapOutput)
}

func (o SlugOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v *Slug) pulumi.IntOutput { return v.Size }).(pulumi.IntOutput)
}

func (o SlugOutput) Stack() pulumi.StringOutput {
	return o.ApplyT(func(v *Slug) pulumi.StringOutput { return v.Stack }).(pulumi.StringOutput)
}

func (o SlugOutput) StackId() pulumi.StringOutput {
	return o.ApplyT(func(v *Slug) pulumi.StringOutput { return v.StackId }).(pulumi.StringOutput)
}

type SlugArrayOutput struct{ *pulumi.OutputState }

func (SlugArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Slug)(nil)).Elem()
}

func (o SlugArrayOutput) ToSlugArrayOutput() SlugArrayOutput {
	return o
}

func (o SlugArrayOutput) ToSlugArrayOutputWithContext(ctx context.Context) SlugArrayOutput {
	return o
}

func (o SlugArrayOutput) Index(i pulumi.IntInput) SlugOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Slug {
		return vs[0].([]*Slug)[vs[1].(int)]
	}).(SlugOutput)
}

type SlugMapOutput struct{ *pulumi.OutputState }

func (SlugMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Slug)(nil)).Elem()
}

func (o SlugMapOutput) ToSlugMapOutput() SlugMapOutput {
	return o
}

func (o SlugMapOutput) ToSlugMapOutputWithContext(ctx context.Context) SlugMapOutput {
	return o
}

func (o SlugMapOutput) MapIndex(k pulumi.StringInput) SlugOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Slug {
		return vs[0].(map[string]*Slug)[vs[1].(string)]
	}).(SlugOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SlugInput)(nil)).Elem(), &Slug{})
	pulumi.RegisterInputType(reflect.TypeOf((*SlugArrayInput)(nil)).Elem(), SlugArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SlugMapInput)(nil)).Elem(), SlugMap{})
	pulumi.RegisterOutputType(SlugOutput{})
	pulumi.RegisterOutputType(SlugArrayOutput{})
	pulumi.RegisterOutputType(SlugMapOutput{})
}
