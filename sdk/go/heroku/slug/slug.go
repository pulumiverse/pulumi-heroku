// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package slug

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-heroku/sdk/go/heroku/internal"
)

// ## Example Usage
//
// Complete config to launch a Heroku app:
//
// ## Import
//
// Existing slugs can be imported using the combination of the application name, a colon, and the slug ID.
//
// For example:
//
// ```sh
// $ pulumi import heroku:slug/slug:Slug foobar bazbux:4f1db8ef-ed5c-4c42-a3d6-3c28262d5abc
// ```
//
// * `foobar` is the **heroku_slug** resource's name
//
// * `bazbux` is the Heroku app name (or ID) that the slug belongs to
//
// * `:` separates the app identifier & the slug identifier
//
// * `4f1db8efâ€¦` is the slug ID
type Slug struct {
	pulumi.CustomResourceState

	// Heroku app ID (do not use app name)
	AppId pulumi.StringOutput `pulumi:"appId"`
	// Slug archive (compressed tar of executable code)
	Blobs SlugBlobArrayOutput `pulumi:"blobs"`
	// Description of language or app framework, `"Ruby/Rack"`;
	// displayed as the app's language in the Heroku Dashboard
	BuildpackProvidedDescription pulumi.StringPtrOutput `pulumi:"buildpackProvidedDescription"`
	// Hash of the slug for verifying its integrity, auto-generated from contents of `filePath` or `fileUrl`,
	// `SHA256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855`
	Checksum pulumi.StringOutput `pulumi:"checksum"`
	// Identification of the code with your version control system (eg: SHA of the git HEAD), `"60883d9e8947a57e04dc9124f25df004866a2051"`
	Commit pulumi.StringPtrOutput `pulumi:"commit"`
	// Description of the provided commit
	CommitDescription pulumi.StringPtrOutput `pulumi:"commitDescription"`
	// Local path to a slug archive, `"slugs/current.tgz"`
	FilePath pulumi.StringPtrOutput `pulumi:"filePath"`
	// **https** URL to a slug archive, `"https://example.com/slugs/app-v1.tgz"`
	FileUrl pulumi.StringPtrOutput `pulumi:"fileUrl"`
	// Map of [processes to launch on Heroku Dynos](https://devcenter.heroku.com/articles/process-model)
	ProcessTypes pulumi.StringMapOutput `pulumi:"processTypes"`
	// Slug archive filesize in bytes
	Size pulumi.IntOutput `pulumi:"size"`
	// Name or ID of the [Heroku stack](https://devcenter.heroku.com/articles/stack)
	Stack pulumi.StringOutput `pulumi:"stack"`
	// [Heroku stack](https://devcenter.heroku.com/articles/stack) ID
	StackId pulumi.StringOutput `pulumi:"stackId"`
}

// NewSlug registers a new resource with the given unique name, arguments, and options.
func NewSlug(ctx *pulumi.Context,
	name string, args *SlugArgs, opts ...pulumi.ResourceOption) (*Slug, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AppId == nil {
		return nil, errors.New("invalid value for required argument 'AppId'")
	}
	if args.ProcessTypes == nil {
		return nil, errors.New("invalid value for required argument 'ProcessTypes'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Slug
	err := ctx.RegisterResource("heroku:slug/slug:Slug", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSlug gets an existing Slug resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSlug(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SlugState, opts ...pulumi.ResourceOption) (*Slug, error) {
	var resource Slug
	err := ctx.ReadResource("heroku:slug/slug:Slug", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Slug resources.
type slugState struct {
	// Heroku app ID (do not use app name)
	AppId *string `pulumi:"appId"`
	// Slug archive (compressed tar of executable code)
	Blobs []SlugBlob `pulumi:"blobs"`
	// Description of language or app framework, `"Ruby/Rack"`;
	// displayed as the app's language in the Heroku Dashboard
	BuildpackProvidedDescription *string `pulumi:"buildpackProvidedDescription"`
	// Hash of the slug for verifying its integrity, auto-generated from contents of `filePath` or `fileUrl`,
	// `SHA256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855`
	Checksum *string `pulumi:"checksum"`
	// Identification of the code with your version control system (eg: SHA of the git HEAD), `"60883d9e8947a57e04dc9124f25df004866a2051"`
	Commit *string `pulumi:"commit"`
	// Description of the provided commit
	CommitDescription *string `pulumi:"commitDescription"`
	// Local path to a slug archive, `"slugs/current.tgz"`
	FilePath *string `pulumi:"filePath"`
	// **https** URL to a slug archive, `"https://example.com/slugs/app-v1.tgz"`
	FileUrl *string `pulumi:"fileUrl"`
	// Map of [processes to launch on Heroku Dynos](https://devcenter.heroku.com/articles/process-model)
	ProcessTypes map[string]string `pulumi:"processTypes"`
	// Slug archive filesize in bytes
	Size *int `pulumi:"size"`
	// Name or ID of the [Heroku stack](https://devcenter.heroku.com/articles/stack)
	Stack *string `pulumi:"stack"`
	// [Heroku stack](https://devcenter.heroku.com/articles/stack) ID
	StackId *string `pulumi:"stackId"`
}

type SlugState struct {
	// Heroku app ID (do not use app name)
	AppId pulumi.StringPtrInput
	// Slug archive (compressed tar of executable code)
	Blobs SlugBlobArrayInput
	// Description of language or app framework, `"Ruby/Rack"`;
	// displayed as the app's language in the Heroku Dashboard
	BuildpackProvidedDescription pulumi.StringPtrInput
	// Hash of the slug for verifying its integrity, auto-generated from contents of `filePath` or `fileUrl`,
	// `SHA256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855`
	Checksum pulumi.StringPtrInput
	// Identification of the code with your version control system (eg: SHA of the git HEAD), `"60883d9e8947a57e04dc9124f25df004866a2051"`
	Commit pulumi.StringPtrInput
	// Description of the provided commit
	CommitDescription pulumi.StringPtrInput
	// Local path to a slug archive, `"slugs/current.tgz"`
	FilePath pulumi.StringPtrInput
	// **https** URL to a slug archive, `"https://example.com/slugs/app-v1.tgz"`
	FileUrl pulumi.StringPtrInput
	// Map of [processes to launch on Heroku Dynos](https://devcenter.heroku.com/articles/process-model)
	ProcessTypes pulumi.StringMapInput
	// Slug archive filesize in bytes
	Size pulumi.IntPtrInput
	// Name or ID of the [Heroku stack](https://devcenter.heroku.com/articles/stack)
	Stack pulumi.StringPtrInput
	// [Heroku stack](https://devcenter.heroku.com/articles/stack) ID
	StackId pulumi.StringPtrInput
}

func (SlugState) ElementType() reflect.Type {
	return reflect.TypeOf((*slugState)(nil)).Elem()
}

type slugArgs struct {
	// Heroku app ID (do not use app name)
	AppId string `pulumi:"appId"`
	// Description of language or app framework, `"Ruby/Rack"`;
	// displayed as the app's language in the Heroku Dashboard
	BuildpackProvidedDescription *string `pulumi:"buildpackProvidedDescription"`
	// Hash of the slug for verifying its integrity, auto-generated from contents of `filePath` or `fileUrl`,
	// `SHA256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855`
	Checksum *string `pulumi:"checksum"`
	// Identification of the code with your version control system (eg: SHA of the git HEAD), `"60883d9e8947a57e04dc9124f25df004866a2051"`
	Commit *string `pulumi:"commit"`
	// Description of the provided commit
	CommitDescription *string `pulumi:"commitDescription"`
	// Local path to a slug archive, `"slugs/current.tgz"`
	FilePath *string `pulumi:"filePath"`
	// **https** URL to a slug archive, `"https://example.com/slugs/app-v1.tgz"`
	FileUrl *string `pulumi:"fileUrl"`
	// Map of [processes to launch on Heroku Dynos](https://devcenter.heroku.com/articles/process-model)
	ProcessTypes map[string]string `pulumi:"processTypes"`
	// Name or ID of the [Heroku stack](https://devcenter.heroku.com/articles/stack)
	Stack *string `pulumi:"stack"`
}

// The set of arguments for constructing a Slug resource.
type SlugArgs struct {
	// Heroku app ID (do not use app name)
	AppId pulumi.StringInput
	// Description of language or app framework, `"Ruby/Rack"`;
	// displayed as the app's language in the Heroku Dashboard
	BuildpackProvidedDescription pulumi.StringPtrInput
	// Hash of the slug for verifying its integrity, auto-generated from contents of `filePath` or `fileUrl`,
	// `SHA256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855`
	Checksum pulumi.StringPtrInput
	// Identification of the code with your version control system (eg: SHA of the git HEAD), `"60883d9e8947a57e04dc9124f25df004866a2051"`
	Commit pulumi.StringPtrInput
	// Description of the provided commit
	CommitDescription pulumi.StringPtrInput
	// Local path to a slug archive, `"slugs/current.tgz"`
	FilePath pulumi.StringPtrInput
	// **https** URL to a slug archive, `"https://example.com/slugs/app-v1.tgz"`
	FileUrl pulumi.StringPtrInput
	// Map of [processes to launch on Heroku Dynos](https://devcenter.heroku.com/articles/process-model)
	ProcessTypes pulumi.StringMapInput
	// Name or ID of the [Heroku stack](https://devcenter.heroku.com/articles/stack)
	Stack pulumi.StringPtrInput
}

func (SlugArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*slugArgs)(nil)).Elem()
}

type SlugInput interface {
	pulumi.Input

	ToSlugOutput() SlugOutput
	ToSlugOutputWithContext(ctx context.Context) SlugOutput
}

func (*Slug) ElementType() reflect.Type {
	return reflect.TypeOf((**Slug)(nil)).Elem()
}

func (i *Slug) ToSlugOutput() SlugOutput {
	return i.ToSlugOutputWithContext(context.Background())
}

func (i *Slug) ToSlugOutputWithContext(ctx context.Context) SlugOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SlugOutput)
}

// SlugArrayInput is an input type that accepts SlugArray and SlugArrayOutput values.
// You can construct a concrete instance of `SlugArrayInput` via:
//
//	SlugArray{ SlugArgs{...} }
type SlugArrayInput interface {
	pulumi.Input

	ToSlugArrayOutput() SlugArrayOutput
	ToSlugArrayOutputWithContext(context.Context) SlugArrayOutput
}

type SlugArray []SlugInput

func (SlugArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Slug)(nil)).Elem()
}

func (i SlugArray) ToSlugArrayOutput() SlugArrayOutput {
	return i.ToSlugArrayOutputWithContext(context.Background())
}

func (i SlugArray) ToSlugArrayOutputWithContext(ctx context.Context) SlugArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SlugArrayOutput)
}

// SlugMapInput is an input type that accepts SlugMap and SlugMapOutput values.
// You can construct a concrete instance of `SlugMapInput` via:
//
//	SlugMap{ "key": SlugArgs{...} }
type SlugMapInput interface {
	pulumi.Input

	ToSlugMapOutput() SlugMapOutput
	ToSlugMapOutputWithContext(context.Context) SlugMapOutput
}

type SlugMap map[string]SlugInput

func (SlugMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Slug)(nil)).Elem()
}

func (i SlugMap) ToSlugMapOutput() SlugMapOutput {
	return i.ToSlugMapOutputWithContext(context.Background())
}

func (i SlugMap) ToSlugMapOutputWithContext(ctx context.Context) SlugMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SlugMapOutput)
}

type SlugOutput struct{ *pulumi.OutputState }

func (SlugOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Slug)(nil)).Elem()
}

func (o SlugOutput) ToSlugOutput() SlugOutput {
	return o
}

func (o SlugOutput) ToSlugOutputWithContext(ctx context.Context) SlugOutput {
	return o
}

// Heroku app ID (do not use app name)
func (o SlugOutput) AppId() pulumi.StringOutput {
	return o.ApplyT(func(v *Slug) pulumi.StringOutput { return v.AppId }).(pulumi.StringOutput)
}

// Slug archive (compressed tar of executable code)
func (o SlugOutput) Blobs() SlugBlobArrayOutput {
	return o.ApplyT(func(v *Slug) SlugBlobArrayOutput { return v.Blobs }).(SlugBlobArrayOutput)
}

// Description of language or app framework, `"Ruby/Rack"`;
// displayed as the app's language in the Heroku Dashboard
func (o SlugOutput) BuildpackProvidedDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Slug) pulumi.StringPtrOutput { return v.BuildpackProvidedDescription }).(pulumi.StringPtrOutput)
}

// Hash of the slug for verifying its integrity, auto-generated from contents of `filePath` or `fileUrl`,
// `SHA256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855`
func (o SlugOutput) Checksum() pulumi.StringOutput {
	return o.ApplyT(func(v *Slug) pulumi.StringOutput { return v.Checksum }).(pulumi.StringOutput)
}

// Identification of the code with your version control system (eg: SHA of the git HEAD), `"60883d9e8947a57e04dc9124f25df004866a2051"`
func (o SlugOutput) Commit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Slug) pulumi.StringPtrOutput { return v.Commit }).(pulumi.StringPtrOutput)
}

// Description of the provided commit
func (o SlugOutput) CommitDescription() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Slug) pulumi.StringPtrOutput { return v.CommitDescription }).(pulumi.StringPtrOutput)
}

// Local path to a slug archive, `"slugs/current.tgz"`
func (o SlugOutput) FilePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Slug) pulumi.StringPtrOutput { return v.FilePath }).(pulumi.StringPtrOutput)
}

// **https** URL to a slug archive, `"https://example.com/slugs/app-v1.tgz"`
func (o SlugOutput) FileUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Slug) pulumi.StringPtrOutput { return v.FileUrl }).(pulumi.StringPtrOutput)
}

// Map of [processes to launch on Heroku Dynos](https://devcenter.heroku.com/articles/process-model)
func (o SlugOutput) ProcessTypes() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Slug) pulumi.StringMapOutput { return v.ProcessTypes }).(pulumi.StringMapOutput)
}

// Slug archive filesize in bytes
func (o SlugOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v *Slug) pulumi.IntOutput { return v.Size }).(pulumi.IntOutput)
}

// Name or ID of the [Heroku stack](https://devcenter.heroku.com/articles/stack)
func (o SlugOutput) Stack() pulumi.StringOutput {
	return o.ApplyT(func(v *Slug) pulumi.StringOutput { return v.Stack }).(pulumi.StringOutput)
}

// [Heroku stack](https://devcenter.heroku.com/articles/stack) ID
func (o SlugOutput) StackId() pulumi.StringOutput {
	return o.ApplyT(func(v *Slug) pulumi.StringOutput { return v.StackId }).(pulumi.StringOutput)
}

type SlugArrayOutput struct{ *pulumi.OutputState }

func (SlugArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Slug)(nil)).Elem()
}

func (o SlugArrayOutput) ToSlugArrayOutput() SlugArrayOutput {
	return o
}

func (o SlugArrayOutput) ToSlugArrayOutputWithContext(ctx context.Context) SlugArrayOutput {
	return o
}

func (o SlugArrayOutput) Index(i pulumi.IntInput) SlugOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Slug {
		return vs[0].([]*Slug)[vs[1].(int)]
	}).(SlugOutput)
}

type SlugMapOutput struct{ *pulumi.OutputState }

func (SlugMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Slug)(nil)).Elem()
}

func (o SlugMapOutput) ToSlugMapOutput() SlugMapOutput {
	return o
}

func (o SlugMapOutput) ToSlugMapOutputWithContext(ctx context.Context) SlugMapOutput {
	return o
}

func (o SlugMapOutput) MapIndex(k pulumi.StringInput) SlugOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Slug {
		return vs[0].(map[string]*Slug)[vs[1].(string)]
	}).(SlugOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SlugInput)(nil)).Elem(), &Slug{})
	pulumi.RegisterInputType(reflect.TypeOf((*SlugArrayInput)(nil)).Elem(), SlugArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SlugMapInput)(nil)).Elem(), SlugMap{})
	pulumi.RegisterOutputType(SlugOutput{})
	pulumi.RegisterOutputType(SlugArrayOutput{})
	pulumi.RegisterOutputType(SlugMapOutput{})
}
